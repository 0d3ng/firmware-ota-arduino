name: PlatformIO Build & Secure OTA (ECDSA-SHA256-P256)

on:
  pull_request:
    branches:
      - master
      - development
    types: [closed]

jobs:
  build-ota:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    environment: firmware env

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache PlatformIO
        uses: actions/cache@v4
        with:
          path: |
            ~/.platformio
            ~/.cache/pip
          key: ${{ runner.os }}-pio-${{ hashFiles('**/platformio.ini') }}

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y zip curl

      - name: Install Python dependencies
        run: pip install platformio cryptography

      - name: Set firmware version info
        run: |
          GIT_HASH=$(git rev-parse --short HEAD)
          BUILD_DATE=$(date "+%Y%m%dT%H%M")
          BUILD_NUMBER=${GITHUB_RUN_NUMBER}
          FIRMWARE_VERSION="${GIT_HASH}-${BUILD_DATE}-build${BUILD_NUMBER}"
          echo "FIRMWARE_VERSION=${FIRMWARE_VERSION}" >> $GITHUB_ENV
          echo "FIRMWARE_ALGORITHM=ecdsa-sha256-p256" >> $GITHUB_ENV
          echo "Firmware version: ${FIRMWARE_VERSION}"
          echo "Firmware algorithm: ${FIRMWARE_ALGORITHM}"

      - name: Build firmware
        run: |
          echo "=== Step 1: Show PlatformIO version ==="
          pio --version

          echo "=== Step 2: Clean build ==="
          pio run --target clean

          echo "=== Step 3: Build firmware ==="
          pio run --environment esp12e

          echo "=== Step 4: Copy firmware-otaq.bin ==="
          cp .pio/build/esp12e/firmware.bin build/firmware-otaq.bin || mkdir -p build && cp .pio/build/esp12e/firmware.bin build/firmware-otaq.bin

          echo "=== Step 5: Show firmware info ==="
          ls -lh build/firmware-otaq.bin

      - name: Upload build logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: platformio-build-logs
          path: .pio/build/esp12e/*.log

      - name: Create manifest.json & package using ECDSA-SHA256-P256
        id: sign_package
        env:
          ECDSA_PRIVATE_KEY_HEX: ${{ secrets.ECDSA_256_PRIVATE_KEY_HEX }}
          VERSION: ${{ env.FIRMWARE_VERSION }}
        run: |
          # measure entire step (python + zip)
          START=$(date +%s%N)

          # measure signing time inside Python and write it into manifest.json
          python3 - <<'EOF'
          import json, hashlib, time
          from cryptography.hazmat.primitives.asymmetric import ec
          from cryptography.hazmat.primitives import serialization
          from cryptography.hazmat.backends import default_backend
          import os

          fw_file = "build/firmware-otaq.bin"
          with open(fw_file, "rb") as f:
              data = f.read()
          digest = hashlib.sha256(data).digest()
          print(f"Firmware {fw_file} size={len(data)} sha256={digest.hex()}")

          # Load private key from GitHub Secrets (hex string - 32 bytes for P-256)
          private_key_hex = os.environ.get("ECDSA_PRIVATE_KEY_HEX","").strip()
          print(f"Private key length: {len(private_key_hex)} chars")

          if len(private_key_hex) != 64:
              raise ValueError(f"Invalid ECDSA private key length: {len(private_key_hex)} (expected 64)")

          # Load ECDSA private key from 32-byte seed (P-256 curve / secp256r1)
          private_value = int.from_bytes(bytes.fromhex(private_key_hex), byteorder='big')
          private_key = ec.derive_private_key(private_value, ec.SECP256R1(), default_backend())
          
          # Get public key and verify it matches config.h
          public_key = private_key.public_key()
          public_numbers = public_key.public_numbers()
          
          # Convert public key to raw format (X||Y, 64 bytes)
          x_bytes = public_numbers.x.to_bytes(32, byteorder='big')
          y_bytes = public_numbers.y.to_bytes(32, byteorder='big')
          public_bytes = x_bytes + y_bytes
          print(f"Public key (X||Y, 64 bytes): {public_bytes.hex()}")
          
          # Sign the 32-byte SHA-256 hash with ECDSA (curve: P-256 / secp256r1)
          # Algorithm: ECDSA-SHA256-P256
          # This produces a DER-encoded signature, we need to extract r and s
          from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature
          from cryptography.hazmat.primitives import hashes
          from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
          
          t0 = time.perf_counter()
          # Sign with ECDSA using prehashed data
          der_signature = private_key.sign(
              digest,
              ec.ECDSA(Prehashed(hashes.SHA256()))
          )
          
          # Decode DER signature to get r and s values
          r, s = decode_dss_signature(der_signature)
          
          # Convert r and s to raw format (32 bytes each)
          r_bytes = r.to_bytes(32, byteorder='big')
          s_bytes = s.to_bytes(32, byteorder='big')
          raw_signature = r_bytes + s_bytes
          
          t1 = time.perf_counter()
          signing_ms = (t1 - t0) * 1000.0
          
          signature_hex = raw_signature.hex()
          print(f"Signature (r||s): {signature_hex[:32]}...")
          print(f"Signature length: {len(raw_signature)} bytes")
          
          # Verify the signature locally to ensure it's correct
          from cryptography.hazmat.primitives.asymmetric.utils import encode_dss_signature
          try:
              # Convert back to DER for verification
              r_verify = int.from_bytes(r_bytes, byteorder='big')
              s_verify = int.from_bytes(s_bytes, byteorder='big')
              der_verify = encode_dss_signature(r_verify, s_verify)
              public_key.verify(der_verify, digest, ec.ECDSA(Prehashed(hashes.SHA256())))
              print("✓ Signature verified locally")
          except Exception as e:
              print(f"✗ Local verification failed: {e}")
              raise

          metadata = {
              "version": os.environ.get("VERSION", "1.0.0"),
              "hash": digest.hex(),
              "signature": signature_hex
          }
          print(f"Manifest: {metadata}")
          with open("manifest.json", "w") as f:
              json.dump(metadata, f, indent=2)

          print(f"Signing elapsed_ms={signing_ms:.3f}")
          EOF

          zip -j firmware.zip build/firmware-otaq.bin manifest.json

          END=$(date +%s%N)
          ELAPSED_MS=$(( (END-START)/1000000 ))
          echo "step_elapsed_ms=$ELAPSED_MS"
          # export as step output for later steps if needed
          echo "step_elapsed_ms=$ELAPSED_MS" >> $GITHUB_OUTPUT

      - name: Upload package via API
        run: |
          STATUS=$(curl -s -o response.txt -w "%{http_code}" \
            -X POST "${{ vars.API_URL }}/firmware/upload" \
            -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
            -F "file=@firmware.zip")

          echo "Response code: $STATUS"
          if [ "$STATUS" -ne 200 ]; then
            echo "❌ Upload failed with status $STATUS"
            cat response.txt
            exit 1
          fi
          echo "✅ Upload successful"
